{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"binaryExponentiation": {
		"prefix": [
			"binary_exp",
			"exponent"
		],
		"body": [
			"//computes a^b is log(a) time",
			"long long binexp(long long a, long long b) {",
			"    long long res = 1;",
			"    while (b > 0) {",
			"        if (b & 1)",
			"            res = res * a;",
			"        a = a * a;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "computes power in log(n) time"
	},
	"Exponentiation Modulo": {
		"prefix": [
			"Modulo exponentiation"
		],
		"body": [
			"//computes (a^b)%m",
			"long long BinExpMod(long long a, long long b, long long m) {",
			"    a %= m;",
			"    long long res = 1;",
			"    while (b > 0) {",
			"        if (b & 1)",
			"            res = res * a % m;",
			"        a = a * a % m;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": ""
	},
	"Euclid_GCD": {
		"prefix": [
			"euclid"
		],
		"body": [
			"int gcd(int a, int b) {",
			"    if (!a || !b)",
			"        return a | b;",
			"    unsigned shift = __builtin_ctz(a | b);",
			"    a >>= __builtin_ctz(a);",
			"    do {",
			"        b >>= __builtin_ctz(b);",
			"        if (a > b)",
			"            swap(a, b);",
			"        b -= a;",
			"    } while (b);",
			"    return a << shift;",
			"}"
		],
		"description": "euclid's gcd algo"
	},
	"Extended Euclidean algo": {
		"prefix": [
			"euclid",
			"extended_euclid"
		],
		"body": [
			"int extended_euclidean(int a, int b, int& x, int& y) {",
			"    if (b == 0) {",
			"        x = 1;",
			"        y = 0;",
			"        return a;",
			"    }",
			"    int x1, y1;",
			"    int d = extended_euclidean(b, a % b, x1, y1);",
			"    x = y1;",
			"    y = x1 - y1 * (a / b);",
			"    return d;",
			"}"
		],
		"description": "extended euclidean algorithm"
	},
	"modulo inverse": {
		"prefix": "modulo_inverse",
		"body": [
			"extended_eucli",
			"int modulo_inverse(int a, int m)",
			"{",
			"    int x, y;",
			"    int g = extended_euclidean(a, m, x, y);",
			"    if (g != 1)",
			"    {",
			"        return -1;",
			"    }",
			"    else",
			"    {",
			"        x = (x % m + m) % m;",
			"        return x;",
			"    }",
			"}"
		],
		"description": "returns modulo inverse of a wrt m"
	},
	"": {
		"prefix": "google",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"",
			"typedef long long ll;",
			"typedef vector<int> vi;",
			"typedef pair<int, int> pi;",
			"typedef vector<vi> vii;",
			"",
			"#define all(x) (x).begin(), (x).end()",
			"#define pb push_back",
			"#define mp make_pair",
			"#define int long long",
			"#define loop(a, n) for (int i = a; i < n; i++)",
			"#define rep(i, k, n) for (i = k; i <= n; ++i)",
			"#define repr(i, k, n) for (i = k; i >= n; --i)",
			"#define tc    \\",
			"    int t;    \\",
			"    cin >> t; \\",
			"    while (t--)",
			"#define no \"NO\" << endl",
			"#define yes \"YES\" << endl",
			"#define speed                   \\",
			"    cin.sync_with_stdio(false); \\",
			"    cin.tie(NULL);              \\",
			"    cout.tie(NULL);",
			"",
			"bool isPrime(int x)",
			"{",
			"    for (int d = 2; d * d <= x; d++)",
			"    {",
			"        if (x % d == 0)",
			"            return false;",
			"    }",
			"    return true;",
			"}",
			"signed main()",
			"{",
			"    speed;",
			"    //#ifndef ONLINE_JUDGE",
			"    //    freopen(\"input.txt\", \"r\", stdin);",
			"    //    freopen(\"output.txt\", \"w\", stdout);",
			"    //#endif //ONLINE_JUDGE",
			"",
			"    int t;",
			"    cin >> t;",
			"    for (int test = 1; test <= t; test++)",
			"    {",
			"",
			"        cout<<\"Case #\"<<test<<\": \"<<ans<<endl;",
			"    }",
			"",
			"    return 0;",
			"}",
			""
		],
		"description": "snippet for google contests"
	},
	"interactive_query": {
		"prefix": [
			"interactive",
			"query"
		],
		"body": [
			"comment speeeeeeeeeeedddddddddddddddddddddddddddddddddddddddddd",
			"int query(int l, int r) {",
			"cout<<\"?\"<<\" \"<<l<<\" \"<<r<<endl; ",
			"fflush(stdout);",
			"int ret;",
			"cin>>ret;",
			"return ret;",
			"}"
		],
		"description": "query l to r"
	},
	"binary_search_implementation": {
		"prefix": [
			"binary_search_implem"
		],
		"body": [
			"int l = 1, r = x;",
			"while (l <= r)",
			"{",
			"int mid = l + (r - l) / 2;",
			"if ()",
			"{",
			"   ;",
			"}",
			"else if ()",
			"{",
			"l = mid + 1;",
			"}",
			"else",
			"{",
			"r = mid - 1;",
			"}",
			"}"
		],
		"description": "code for binary search"
	},
	"1var1array": {
		"prefix": [
			"onevaronearray",
			"1var1array"
		],
		"body": [
			"int n;",
			"cin >> n;",
			"vector<int> a(n);",
			"FOR(i,0, n)",
			"{",
			"    cin >> a.at(i);",
			"}"
		],
		"description": "inputs a var and vector"
	},
	"bfs": {
		"prefix": "bfs_template",
		"body": [
			"////////////////////////////////////////////////////",
			"// BFS Code",
			"int s; // source vertex",
			"queue<int> q;",
			"vector<bool> used(1e5+5);\t\t//alter size",
			"vector<int> d(1e5+5), p(1e5+5);\t\t//alter size",
			"void bfs(int s)\t\t//s is the source here",
			"{",
			"\tq.push(s);",
			"\tused[s] = true;",
			"\tp[s] = -1;",
			"\twhile (!q.empty())",
			"\t{",
			"\t\tint v = q.front();",
			"\t\tq.pop();",
			"\t\tfor (int u : g[v])",
			"\t\t{",
			"\t\t\tif (!used[u])",
			"\t\t\t{",
			"\t\t\t\tused[u] = true;",
			"\t\t\t\tq.push(u);",
			"\t\t\t\td[u] = d[v] + 1;",
			"\t\t\t\tp[u] = v;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "bfs template"
	},
	"bfs_shortest_path": {
		"prefix": "bfs_shortest_path",
		"body": [
			"// use this after the bfs code",
			"// first call bfs on source node",
			"// then call bfsShortestPath() on all nodes for which path is to be found",
			"void bfsShortestPath(int u)",
			"{",
			"\tif (!used[u])",
			"\t{",
			"\t\tcout << \"No path!\";",
			"\t}",
			"\telse",
			"\t{",
			"\t\tvector<int> path;",
			"\t\tfor (int v = u; v != -1; v = p[v])",
			"\t\t\tpath.push_back(v);",
			"\t\treverse(path.begin(), path.end());",
			"\t\tcout << \"Path: \";",
			"\t\tfor (int v : path)",
			"\t\t\tcout << v << \" \";",
			"\t}",
			"}"
		],
		"description": "shortest path from source to u"
	},
	"graph_problems_template": {
		"prefix": "graph_template",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"",
			"#define int long long",
			"typedef long long ll;",
			"typedef vector<int> vi;",
			"typedef pair<int, int> pi;",
			"typedef vector<vi> vii;",
			"",
			"#define speed                   \\",
			"\tcin.sync_with_stdio(false); \\",
			"\tcin.tie(NULL);              \\",
			"\tcout.tie(NULL);",
			"#define all(x) (x).begin(), (x).end()",
			"#define pb push_back",
			"#define mp make_pair",
			"#define loop(a, n) for (int i = a; i < n; i++)",
			"#define rep(i, k, n) for (i = k; i <= n; ++i)",
			"#define repr(i, k, n) for (i = k; i >= n; --i)",
			"#define tc    \\",
			"\tint t;    \\",
			"\tcin >> t; \\",
			"\twhile (t--)",
			"#define no \"NO\" << endl",
			"#define yes \"YES\" << endl",
			"",
			"vii g(1e5+5);      // alter size here",
			"int n;             // no. of vertices",
			"void addEdge(int a, int b)",
			"{",
			"\tg[a].pb(b);",
			"\t// for undirected graph add this line",
			"\t// g[b].pb(a);",
			"}",
			"",
			"// extra functions here",
			"",
			"",
			"signed main()",
			"{",
			"\tspeed;",
			"\t//#ifndef ONLINE_JUDGE",
			"\t//    freopen(\"input.txt\", \"r\", stdin);",
			"\t//    freopen(\"output.txt\", \"w\", stdout);",
			"\t//#endif //ONLINE_JUDGE",
			"",
			"\ttc",
			"\t{",
			"\t\t// int m,k;",
			"\t\t// int m;",
			"\t\t// cin>>n;          //n by default is number of vertices",
			"\t\t// loop(0, m)",
			"\t\t// {",
			"\t\t//     int v1, v2;",
			"\t\t//     cin >> v1 >> v2;",
			"\t\t//     // v1--;v2--;",
			"\t\t//     addEdge(v1, v2);",
			"\t\t// }",
			"",
			"\t}",
			"",
			"\treturn 0;",
			"}"
		],
		"description": "template for graph problems"
	},
	"DFS_template": {
		"prefix": "dfs_template",
		"body": [
			"////////////////////////////////////////////////////",
			"// DFS Code",
			"// not visited = 0",
			"// visited     = 1",
			"// exited      = 2",
			"vector<int> color(1e5+5,0);",
			"",
			"vector<int> time_in(1e5+5), time_out(1e5+5);",
			"int dfs_timer = 0;",
			"",
			"void dfs(int v)       //v is the source here",
			"{",
			"\ttime_in[v] = dfs_timer++;",
			"\tcolor[v] = 1;",
			"\tfor (int u : g[v])",
			"\t{",
			"\t\tif (color[u] == 0)",
			"\t\t{",
			"\t\t\tdfs(u);",
			"\t\t\t// make changes here",
			"\t\t}",
			"\t}",
			"\tcolor[v] = 2;",
			"\ttime_out[v] = dfs_timer++;",
			"}"
		],
		"description": "template for DFS from source s"
	},
	"grid_dfs_tempate": {
		"prefix": "grid_dfs_tempate",
		"body": [
			"///////////////////////////////////////////////////////////////////////",
			"// not visited = 0",
			"// visited     = 1",
			"// exited      = 2",
			"// mark all of them as 0 wwhile getting input",
			"// #define rowsize",
			"// #define rowsize",
			"int color[colsize + 5][rowsize + 5];",
			"char graph[colsize + 5][rowsize + 5]; // change to int if required",
			"int time_in[colsize + 5][rowsize + 5];",
			"int time_out[colsize + 5][rowsize + 5];",
			"// direction vectors",
			"// only left, right , up ,down are allowed here",
			"int dx[] = {1, -1, 0, 0};",
			"int dy[] = {0, 0, 1, -1};",
			"",
			"// // if all 8 directions--> change loops to 8",
			"// int X[] = {1, 0, -1, 0, 1, -1, 1, -1};",
			"// int Y[] = {0, 1, 0, -1, 1, 1, -1, -1};",
			"",
			"int m, n;",
			"bool cycle = false;",
			"int dfs_timer = 0;",
			"// (i,j)       -> new coordinates",
			"// (frmi,frmj) -> prev coordinates (from where the dfs() was called)",
			"void dfs(int i, int j, int frmi, int frmj)",
			"{",
			"\tif (i < 0 || j < 0 || i >= n || j >= m)",
			"\t{",
			"\t\treturn;    // checks if the coordinates are valid",
			"\t}",
			"",
			"\t// checks for cycle",
			"\tif (color[i][j] == 1)",
			"\t{",
			"\t\tcycle = true;",
			"\t\treturn;",
			"\t}",
			"",
			"\t// make changes here (if required)--extra condition",
			"",
			"\t// mark the coordinates as visited",
			"\tcolor[i][j] = 1;",
			"\ttime_in[i][j] = dfs_timer++;",
			"",
			"\tfor (int y = 0; y < 4; y++)",
			"\t{",
			"\t\tint nxti = i + dx[y];",
			"\t\tint nxtj = j + dy[y];",
			"",
			"\t\tif (nxti == frmi && nxtj == frmj)",
			"\t\t{",
			"\t\t\tcontinue; // it doesn't go back to where it came from",
			"\t\t}",
			"\t\t// make changes here (if required)",
			"\t\tdfs(nxti, nxtj, i, j);",
			"\t\t//add condition if u wanna break if cycle is found",
			"\t}",
			"\tcolor[i][j] = 2;",
			"\ttime_out[i][j] = dfs_timer++;",
			"}"
		],
		"description": "grid dfs tempate"
	},
	"grid_bfs_tempate": {
		"prefix": "grid_bfs_tempate",
		"body": [
			"////////////////////////////___GRID BFS___//////////////////////////////////////////",
			"//Direction Vectors to generate 4 neighbors of the cell",
			"int X[] = {0, 1, 0, -1};",
			"int Y[] = {-1, 0, 1, 0};",
			"",
			"// // if all 8 directions--> change loops to 8",
			"// int X[] = {1, 0, -1, 0, 1, -1, 1, -1};",
			"// int Y[] = {0, 1, 0, -1, 1, 1, -1, -1};",
			"",
			"#define colsize 1 // n -> i",
			"#define rowsize 1 // m -> j",
			"int n, m;",
			"char g[colsize + 5][rowsize + 5];",
			"bool visited[colsize + 5][rowsize + 5];",
			"int distances[colsize + 5][rowsize + 5];",
			"pair<int, int> parent[colsize + 5][rowsize + 5];",
			"queue<pair<int, int>> q;",
			"",
			"//The validator function",
			"bool isvalid(int i, int j, int m, int n)",
			"{",
			"\treturn ((i >= 0 && i < n && j >= 0 && j < m) && !visited[i][j]);",
			"}",
			"void bfs_grid(int i, int j)",
			"{",
			"\tq.push({i, j});",
			"\tdistances[i][j] = 0;",
			"\tvisited[i][j] = true;",
			"\twhile (!q.empty())",
			"\t{",
			"\t\tint currX = q.front().first;",
			"\t\tint currY = q.front().second;",
			"\t\tq.pop();",
			"",
			"\t\tfor (int i = 0; i < 4; i++) //change to 8 if reqd.",
			"\t\t{",
			"\t\t\tint newX = currX + X[i];",
			"\t\t\tint newY = currY + Y[i];",
			"\t\t\tif (newX < 0 || newY < 0 || newY >= m || newX >= n)",
			"\t\t\t{",
			"\t\t\t\tcontinue; // checks if the coordinates are valid",
			"\t\t\t}",
			"\t\t\tif (visited[newX][newY])",
			"\t\t\t{",
			"\t\t\t\tcontinue;",
			"\t\t\t}",
			"",
			"\t\t\tdistances[newX][newY] = distances[currX][currY] + 1;",
			"\t\t\tvisited[newX][newY] = 1;",
			"\t\t\tparent[newX][newY] = {currX, currY};",
			"\t\t\tq.push({newX, newY});",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "grid_bfs_tempate"
	},
	"ConnectedComponents_DFS": {
		"prefix": "connected_Components_DFS",
		"body": [
			"/////////////////////////////___Find Connected Components___///////////////////////////////////",
			"comp.pb(v);used[v]=true; //add this line in DFS function on top",
			"vector<int> comp(1e5 + 5);",
			"bool used[(ll)1e5 + 5];",
			"// returns the number of connected components",
			"int ConnectedComps()",
			"{",
			"\tint compnentsCount = 0;",
			"\tfor (int i = 0; i < n; ++i)",
			"\t{",
			"\t\tused[i] = false;",
			"\t}",
			"\tfor (int i = 0; i < n; ++i)         // change to 1 & <= for 1 based indexing",
			"\t{",
			"\t\tif (!used[i])",
			"\t\t{",
			"\t\t\tcomp.clear();",
			"\t\t\tcompnentsCount++;",
			"\t\t\tdfs(i);",
			"\t\t\t// accessing the components",
			"\t\t\t// cout << \"Component \"<<compnentsCount<<\" :\";",
			"\t\t\t// for (size_t j = 0; j < comp.size(); ++j)",
			"\t\t\t//     cout << ' ' << comp[j];",
			"\t\t\t// cout << endl;",
			"\t\t}",
			"\t}",
			"\treturn compnentsCount;",
			"}"
		],
		"description": "Connected Components using DFS"
	},
	"ConnectedComponents_grid": {
		"prefix": "grid_connected_components",
		"body": [
			"///////////////___Find Connected Components Grid___///////////////",
			"comp.pb({i, j}); used[i][j] = true; //add this line in DFS function on top",
			"vector<pair<int, int>> comp(rowsize *colsize + 5);",
			"bool used[colsize + 5][rowsize + 5];",
			"// returns the number of connected components",
			"int ConnectedComps()",
			"{",
			"\tint compnentsCount = 0;",
			"\tfor (int i = 0; i < n; ++i)",
			"\t{",
			"\t\tfor (int j = 0; j < m; j++)",
			"\t\t{",
			"\t\t\tused[i][j] = false;",
			"\t\t}",
			"\t}",
			"\tfor (int i = 0; i < n; ++i) // change to 1 & <= for 1 based indexing",
			"\t{",
			"\t\tfor (int j = 0; j < m; j++)",
			"\t\t{",
			"\t\t\tif (!used[i][j] && graph[i][j]=='#')",
			"\t\t\t{",
			"\t\t\t\tcomp.clear();",
			"\t\t\t\tcompnentsCount++;",
			"\t\t\t\tdfs(i, j, -1, -1);",
			"\t\t\t\t// accessing the components",
			"\t\t\t\t// cout << \"Component \" << compnentsCount << \" :\";",
			"\t\t\t\t// for (size_t j = 0; j < comp.size(); ++j)",
			"\t\t\t\t//     cout << comp[j].first << ' ' << comp[j].second << \" , \";",
			"\t\t\t\t// cout << endl;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn compnentsCount;",
			"}"
		],
		"description": "Connected Components Grid"
	},
	"0/1 knapsack": {
		"prefix": "knapsack",
		"body": [
			"// #define maxW 2000",
			"\t// #define maxN 2000",
			"\t//     int dp[maxN + 5][maxW + 5];",
			"\t//     //    |---------->W",
			"\t//     //    |",
			"\t//     //    |",
			"\t//     //   \\|/",
			"\t//     //    N",
			"\tint capacity, n;",
			"\tcin >> capacity >> n;",
			"\tvector<int> weights(n);",
			"\tvector<int> values(n);",
			"\t// Initialization",
			"\tfor (int i = 0; i < max(maxW, maxN) + 3; i++)",
			"\t{",
			"\t\tif (i <= maxW + 3)",
			"\t\t\tdp[0][i] = 0;",
			"\t\tif (i <= maxN + 3)",
			"\t\t\tdp[i][0] = 0;",
			"\t}",
			"\t// get inputs here",
			"\tloop(0, n)",
			"\t{",
			"\t\tcin >> weights.at(i) >> values.at(i);",
			"\t}",
			"\t// -----inputs taken------",
			"",
			"\t//dp part",
			"\tfor (int i = 1; i < n + 1; i++) // i is the items (n)",
			"\t{",
			"\t\tfor (int j = 1; j < capacity + 1; j++)  // j is the weights in subp (W)",
			"\t\t{",
			"\t\t\tif (weights[i - 1] <= j)    // if can be added",
			"\t\t\t{",
			"\t\t\t\tdp[i][j] = max(dp[i - 1][j], values[i - 1] + dp[i - 1][j - weights[i - 1]]);",
			"\t\t\t\t// get max of 1) If this item is not added and all prev items are used ",
			"\t\t\t\t//               with same capacity of knapsack",
			"\t\t\t\t//            2) Item added + best value if capacity was curr_cap - item_wt",
			"\t\t\t}",
			"\t\t\telse",
			"\t\t\t{",
			"\t\t\t\tdp[i][j] = dp[i - 1][j];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t// cout << dp[n][capacity];    // last cell"
		],
		"description": "0/1 knapsack"
	},
	"toposort": {
		"prefix": [
			"toposort",
			"topological sort",
			"DAG"
		],
		"body": [
			"///////////////////////////////////////////////////////////////////////////////////////////",
			"// toposort algo",
			"",
			"ordering.push_front(v); // add this just before the return statement in DFS",
			"list<int> ordering;",
			"",
			"void toposort()",
			"{",
			"\t// initialise all colors to 0 either here or in main",
			"",
			"\tfor (int i = 0; i < n; i++)",
			"\t{",
			"\t\tif (color[i] == 0)",
			"\t\t{",
			"\t\t\tdfs(i);",
			"\t\t}",
			"\t}",
			"",
			"\t//call dfs from each unvisited node",
			"\tfor (int i = 0; i < n; i++)",
			"\t{",
			"\t\tif (color[i] == 0)",
			"\t\t{",
			"\t\t\tdfs(i);",
			"\t\t}",
			"\t}",
			"",
			"\t// accessing the ordering",
			"\t// for (auto it : ordering)",
			"\t// {",
			"\t//     cout << it << \" -> \";",
			"\t// }",
			"\t// cout << endl;",
			"}"
		],
		"description": "topologically sort a DAG"
	},
	"DSU implementation": {
		"prefix": [
			"dsu"
		],
		"body": [
			"class UnionFind",
			"{",
			"private:",
			"\tvector<int> p, rank, setSize;",
			"\tint numSets;",
			"",
			"public:",
			"\tUnionFind(int N)",
			"\t{",
			"\t\tsetSize.assign(N, 1);",
			"\t\tnumSets = N;",
			"\t\trank.assign(N, 0);",
			"\t\tp.assign(N, 0);",
			"\t\tfor (int i = 0; i < N; i++)",
			"\t\t\tp[i] = i;",
			"\t}",
			"\tint findSet(int i) { return (p[i] == i) ? i : (p[i] = findSet(p[i])); }",
			"\tbool isSameSet(int i, int j) { return findSet(i) == findSet(j); }",
			"\tvoid unionSet(int i, int j)",
			"\t{",
			"\t\tif (!isSameSet(i, j))",
			"\t\t{",
			"\t\t\tnumSets--;",
			"\t\t\tint x = findSet(i), y = findSet(j);",
			"\t\t\tif (rank[x] > rank[y])",
			"\t\t\t{",
			"\t\t\t\tp[y] = x;",
			"\t\t\t\tsetSize[x] += setSize[y];",
			"\t\t\t}",
			"\t\t\telse",
			"\t\t\t{",
			"\t\t\t\tp[x] = y;",
			"\t\t\t\tsetSize[y] += setSize[x];",
			"\t\t\t\tif (rank[x] == rank[y])",
			"\t\t\t\t\trank[y]++;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tint numDisjointSets() { return numSets; }",
			"\tint sizeOfSet(int i) { return setSize[findSet(i)]; }",
			"};"
		],
		"description": "DSU implementation"
	},
	"bipartite check/parity using DSU": {
		"prefix": [
			"bipartite_parity",
			"dsu_bipartite"
		],
		"body": [
			"/////////////////////////////////////////////////////////////////////////////////////////////////",
			"/////////////////////////////////////////////////////////////////////////////////////////////////",
			"// 1. adjust maxN",
			"// 2. for all elements (individual elements): call make_set(i)",
			"// 3. for all edges, call the add_edge(u,v) function. check if u--; v--; is required",
			"// 4. to get leader/parent use find_set(). the first element is parent id and second ",
			"//    element is the parity",
			"",
			"",
			"#define maxN 200000 + 4",
			"pi parent[maxN];",
			"int rank_[maxN];",
			"bool bipartite[maxN];",
			"",
			"void make_set(int v)",
			"{",
			"\tparent[v] = make_pair(v, 0);",
			"\trank_[v] = 0;",
			"\tbipartite[v] = true;",
			"}",
			"",
			"pair<int, int> find_set(int v)",
			"{",
			"\tif (v != parent[v].first)",
			"\t{",
			"\t\tint parity = parent[v].second;",
			"\t\tparent[v] = find_set(parent[v].first);",
			"\t\tparent[v].second ^= parity;",
			"\t}",
			"\treturn parent[v];",
			"}",
			"",
			"void add_edge(int a, int b)",
			"{",
			"\tpair<int, int> pa = find_set(a);",
			"\ta = pa.first;",
			"\tint x = pa.second;",
			"",
			"\tpair<int, int> pb = find_set(b);",
			"\tb = pb.first;",
			"\tint y = pb.second;",
			"",
			"\tif (a == b)",
			"\t{",
			"\t\tif (x == y)",
			"\t\t\tbipartite[a] = false;",
			"\t}",
			"\telse",
			"\t{",
			"\t\tif (rank_[a] < rank_[b])",
			"\t\t\tswap(a, b);",
			"\t\tparent[b] = make_pair(a, x ^ y ^ 1);",
			"\t\tbipartite[a] &= bipartite[b];",
			"\t\tif (rank_[a] == rank_[b])",
			"\t\t\t++rank_[a];",
			"\t}",
			"}",
			"",
			"bool is_bipartite(int v)",
			"{",
			"\treturn bipartite[find_set(v).first];",
			"}"
		],
		"description": "check bipartite prop. get parity/color of elements if bipartite"
	},
	"kruskal's MST algo": {
		"prefix": "kruskal",
		"body": [
			"////////////////////////////////////////////////////////////////////////////////////",
			"// Kruskal's algo for MST",
			"// first part is DSU. then we greedily add edges checking if the nodes are",
			"// already in same component using DSU.",
			"// edge structure stores u,v,w. edges array stores input. result stores MST edges.",
			"// 1. get n and m",
			"// 2. add edges --> if u r using tc, use edges.clear() to be safe.",
			"// 3. do u--;v--; because everything is 0 indexed                                             (imp)",
			"// 4. call kruskals: it returns the cost of MST (make result global if required)",
			"// 5. **** The algorithm just finds MST **if the graph is connected**                         (imp)",
			"// 6. to check if it actually spans, you need to use DSU..check if parent of all is same",
			"// 7. use prepKruskal() if allowed.",
			"",
			"vector<int> parent, rank_,setSize;",
			"",
			"void make_set(int v)",
			"{",
			"\tparent[v] = v;",
			"\trank_[v] = 0;",
			"\tsetSize[v] = 0;",
			"}",
			"",
			"int find_set(int v)",
			"{",
			"\tif (v == parent[v])",
			"\t\treturn v;",
			"\treturn parent[v] = find_set(parent[v]);",
			"}",
			"",
			"void union_sets(int a, int b)",
			"{",
			"\ta = find_set(a);",
			"\tb = find_set(b);",
			"\tif (a != b)",
			"\t{",
			"\t\tif (rank_[a] < rank_[b])",
			"\t\t\tswap(a, b);",
			"\t\tparent[b] = a;",
			"\t\tif (rank_[a] == rank_[b])",
			"\t\t\trank_[a]++;",
			"\t\tsetSize[a]+=setSize[b];",
			"\t}",
			"}",
			"",
			"struct Edge",
			"{",
			"\tint u, v, weight;",
			"\tbool operator<(Edge const &other)",
			"\t{",
			"\t\treturn weight < other.weight;",
			"\t}",
			"};",
			"",
			"int n;",
			"vector<Edge> edges;",
			"bool MSTexists = true;",
			"",
			"int kruskal()",
			"{",
			"\tint cost = 0;",
			"\tvector<Edge> result;",
			"\tparent.resize(n);",
			"\trank_.resize(n);",
			"\tsetSize.resize(n);",
			"\tfor (int i = 0; i < n; i++)",
			"\t\tmake_set(i);",
			"",
			"\tsort(edges.begin(), edges.end());",
			"",
			"\tfor (Edge e : edges)",
			"\t{",
			"\t\tif (find_set(e.u) != find_set(e.v))",
			"\t\t{",
			"\t\t\tcost += e.weight;",
			"\t\t\tresult.push_back(e);",
			"\t\t\tunion_sets(e.u, e.v);",
			"\t\t}",
			"\t}",
			"",
			"\t// checking MST exists or not",
			"\t// for (int i = 1; i < n; i++)",
			"\t// {",
			"\t//     if (find_set(i - 1) != find_set(i))",
			"\t//     {",
			"\t//         MSTexists = false;",
			"\t//         break;",
			"\t//     }",
			"\t// }",
			"",
			"\t//accessing final MST",
			"\t// for (auto e : result)",
			"\t// {",
			"\t//     cout << e.u << \" \" << e.v << \" \" << e.weight << \"\\n\";",
			"\t// }",
			"\treturn cost;",
			"}",
			"int prepKruskal()",
			"{",
			"\tint m;",
			"\tcin >> m;",
			"\tedges.clear();",
			"\tloop(0, m)",
			"\t{",
			"\t\tint u, v, w;",
			"\t\tcin >> u >> v >> w;",
			"\t\tu--;",
			"\t\tv--;",
			"\t\tedges.pb({u, v, w});",
			"\t}",
			"\treturn m;",
			"}"
		],
		"description": "kruskal algo implementation using DSU"
	},
	"Segment Tree": {
		"prefix": "segtree",
		"body": [
			"template <typename T>",
			"struct segTree {",
			"\tT unit;",
			"\tT (*f) (T obj1, T obj2);",
			"\tvector<T> s;",
			"\tint n;",
			"\tsegTree(int n, T (*c)(T obj1, T obj2), T def) : s(2 * n, def), n(n), f(c), unit(def) {}",
			"\tvoid update(int pos, T val) {",
			"\t\tfor (s[pos += n] = val; pos /= 2;)",
			"\t\t\ts[pos] = f(s[pos * 2], s[pos * 2 + 1]);",
			"\t}",
			"\tT query(int b, int e) {  // query [b, e]",
			"\t\te++;",
			"\t\tT ra = unit, rb = unit;",
			"\t\tfor (b += n, e += n; b < e; b /= 2, e /= 2) {",
			"\t\t\tif (b % 2) ra = f(ra, s[b++]);",
			"\t\t\tif (e % 2) rb = f(s[--e], rb);",
			"\t\t}",
			"\t\treturn f(ra, rb);",
			"\t}",
			"};"
		],
		"description": "segtree O(4nlogn) ig"
	},
	"sparse table": {
		"prefix": [
			"sparseTable"
		],
		"body": [
			"////////////////////////////////////////////////////////////////////",
			"// Sparse Table class implementation",
			"// constructor params: vect.begin(), vect.end(), joinFunction",
			"// returns the answer for query for [l,r] (inclusive) -> 0 based indexing",
			"template <typename T>",
			"",
			"class sparse_table",
			"{",
			"",
			"private:",
			"\tstd::vector<T> data;",
			"",
			"\tstd::vector<std::vector<size_t>> table;",
			"",
			"\tvoid build_table();",
			"",
			"\tT(*combine)",
			"\t(T obj1, T obj2);",
			"",
			"\tinline static unsigned mlog(size_t _n);",
			"",
			"public:",
			"\tconst size_t size() const { return data.size(); }",
			"",
			"\tsparse_table(const std::vector<T> &_data) : data(_data)",
			"\t{",
			"",
			"\t\tbuild_table();",
			"\t}",
			"",
			"\ttemplate <typename ItT>",
			"",
			"\tsparse_table(ItT begin, ItT end, T (*combine)(T obj1, T obj2))",
			"\t{",
			"\t\tthis->combine = combine;",
			"\t\twhile (begin != end)",
			"\t\t{",
			"\t\t\tdata.push_back(*begin);",
			"\t\t\t++begin;",
			"\t\t}",
			"",
			"\t\tbuild_table();",
			"\t}",
			"\tT query(const size_t L, const size_t R);",
			"};",
			"",
			"template <typename T>",
			"",
			"void sparse_table<T>::build_table()",
			"{",
			"",
			"\tif (!data.size())",
			"\t{",
			"",
			"\t\tthrow std::invalid_argument(\"Empty set is passet as a parameter.\");",
			"\t}",
			"",
			"\ttable.resize(1);",
			"",
			"\ttable[0].resize(data.size());",
			"",
			"\tfor (size_t i = 0; i < data.size(); ++i)",
			"\t{",
			"",
			"\t\ttable[0][i] = data[i];",
			"\t}",
			"",
			"\tunsigned pow = 1;",
			"",
			"\tconst unsigned max_pow = mlog(data.size());",
			"",
			"\ttable.resize(max_pow + 1);",
			"",
			"\t// const Comp cmp;",
			"",
			"\tfor (; pow <= max_pow; ++pow)",
			"\t{",
			"",
			"\t\tconst size_t cur_step_len = static_cast<size_t>(1) << pow,",
			"",
			"\t\t\t\t\t prev_step_len = static_cast<size_t>(1) << (pow - 1);",
			"",
			"\t\ttable[pow].resize(data.size() - cur_step_len + 1);",
			"",
			"\t\tfor (int i = 0; i <= data.size() - cur_step_len; ++i)",
			"\t\t{",
			"",
			"\t\t\ttable[pow][i] = combine(table[pow - 1][i], table[pow - 1][i + prev_step_len]);",
			"\t\t}",
			"\t}",
			"}",
			"",
			"template <typename T>",
			"",
			"inline unsigned sparse_table<T>::mlog(const size_t _n)",
			"{",
			"",
			"\tregister size_t n = _n, k = 0;",
			"",
			"\twhile ((static_cast<size_t>(1) << k) <= n)",
			"\t{",
			"",
			"\t\t++k;",
			"\t}",
			"",
			"\treturn k - 1;",
			"}",
			"",
			"template <typename T>",
			"// query from [l,r] 0-based indexing",
			"T sparse_table<T>::query( size_t L,  size_t R)",
			"{",
			"\tR++;",
			"\tif (L > data.size() || R == 0 || R > data.size())",
			"\t{",
			"\t\tthrow std::out_of_range(\"Wrong index is used.\");",
			"\t}",
			"",
			"\tif (L >= R)",
			"\t{",
			"\t\tthrow std::invalid_argument(\"Wrong arguments in query.\");",
			"\t}",
			"\tconst unsigned pow = mlog(R - L);",
			"",
			"\tconst size_t check_len = static_cast<size_t>(1) << pow;",
			"",
			"\treturn T(combine(table[pow][L], table[pow][R - check_len]));",
			"}"
		],
		"description": "sparse table general implementation"
	},
	"String Hashing": {
		"prefix": [
			"hashing",
			"stringHash"
		],
		"body": [
			"////////////////////////////////////////////////////////////////////////////////////////",
			"// 1-based String Hash ",
			"// alter size of N based on needs.",
			"// run prec() in main.",
			"// use as \"Hashing variableName(stringToBeHashed)\".",
			"// get_hash(l,r) method returns the hash value for substring [l,r] in one-based indexing. It uses double hashing => returns a pair of integers corresponding to hashes from the 2 MODs",
			"",
			"const int N = 4e6 + 9;",
			"",
			"int power(long long n, long long k, const int mod) {",
			"\tint ans = 1 % mod;",
			"\tn %= mod;",
			"\tif (n < 0) n += mod;",
			"\twhile (k) {",
			"\t\tif (k & 1) ans = (long long)ans * n % mod;",
			"\t\tn = (long long)n * n % mod;",
			"\t\tk >>= 1;",
			"\t}",
			"\treturn ans;",
			"}",
			"",
			"const int MOD1 = 127657753, MOD2 = 987654319;",
			"const int p1 = 137, p2 = 277;",
			"int ip1, ip2;",
			"pair<int, int> pw[N], ipw[N];",
			"void prec() {",
			"\tpw[0] = {1, 1};",
			"\tfor (int i = 1; i < N; i++) {",
			"\t\tpw[i].first = 1LL * pw[i - 1].first * p1 % MOD1;",
			"\t\tpw[i].second = 1LL * pw[i - 1].second * p2 % MOD2;",
			"\t}",
			"\tip1 = power(p1, MOD1 - 2, MOD1);",
			"\tip2 = power(p2, MOD2 - 2, MOD2);",
			"\tipw[0] = {1, 1};",
			"\tfor (int i = 1; i < N; i++) {",
			"\t\tipw[i].first = 1LL * ipw[i - 1].first * ip1 % MOD1;",
			"\t\tipw[i].second = 1LL * ipw[i - 1].second * ip2 % MOD2;",
			"\t}",
			"}",
			"struct Hashing {",
			"\tint n;",
			"\tstring s;                   // 0 - indexed",
			"\tvector<pair<int, int>> hs;  // 1 - indexed",
			"\tHashing() {}",
			"\tHashing(string _s) {",
			"\t\tn = _s.size();",
			"\t\ts = _s;",
			"\t\ths.emplace_back(0, 0);",
			"\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\tpair<int, int> p;",
			"\t\t\tp.first = (hs[i].first + 1LL * pw[i].first * s[i] % MOD1) % MOD1;",
			"\t\t\tp.second = (hs[i].second + 1LL * pw[i].second * s[i] % MOD2) % MOD2;",
			"\t\t\ths.push_back(p);",
			"\t\t}",
			"\t}",
			"\tpair<int, int> get_hash(int l, int r) {  // 1 - indexed",
			"\t\tif (1 <= l && l <= r && r <= n) {",
			"\t\t\tpair<int, int> ans;",
			"\t\t\tans.first = (hs[r].first - hs[l - 1].first + MOD1) * 1LL * ipw[l - 1].first % MOD1;",
			"\t\t\tans.second = (hs[r].second - hs[l - 1].second + MOD2) * 1LL * ipw[l - 1].second % MOD2;",
			"\t\t\treturn ans;",
			"\t\t}",
			"\t\treturn {-1, -1};",
			"\t}",
			"\tpair<int, int> get_hash() {",
			"\t\treturn get_hash(1, n);",
			"\t}",
			"};"
		],
		"description": "Struct for string hashing. Double hash 1-based indexing"
	},
	"unorderedMapCustomHash": {
		"prefix": [
			"unordered_map_custom_hash",
			"hash",
			"custom_hash"
		],
		"body": [
			"struct custom_hash {",
			"\tstatic uint64_t splitmix64(uint64_t x) {",
			"\t\t// http://xorshift.di.unimi.it/splitmix64.c",
			"\t\tx += 0x9e3779b97f4a7c15;",
			"\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"\t\treturn x ^ (x >> 31);",
			"\t}",
			"",
			"\tsize_t operator()(uint64_t x) const {",
			"\t\tstatic const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
			"\t\treturn splitmix64(x + FIXED_RANDOM);",
			"\t}",
			"};"
		],
		"description": "custom_hash_for_u_map"
	},
	"Sieve,Primes less than MAXN": {
		"prefix": [
			"sieve",
			"primes_less_than_MAXN"
		],
		"body": [
			"works with MAXN upto 1e7 but change as per constraints",
			"#define MAXN (int)1e7 + 5",
			"vector<int> primes;",
			"bitset<MAXN + 5> isPrime;",
			"void getPrimes()",
			"{",
			"\tisPrime.set();",
			"\tisPrime[0] = isPrime[1] = 0;",
			"\tfor (int i = 2; i <= sqrt(MAXN) + 2; i++)",
			"\t{",
			"\t\tif (isPrime[i])",
			"\t\t{",
			"\t\t\tprimes.push_back(i);",
			"\t\t\tfor (int j = i * i; j <= MAXN; j += i)",
			"\t\t\t\tisPrime[j] = 0;",
			"\t\t}",
			"\t}",
			"\tFOR(i, sqrt(MAXN) + 3, MAXN)",
			"\tif (isPrime[i])",
			"\t\tprimes.PB(i);",
			"}"
		],
		"description": "sieve/primes less than N"
	},
	"mod_add_mult": {
		"prefix": [
			"mod_add_mult",
			"mod_mult",
			"modulo_add"
		],
		"body": [
			"LL mod_mul(LL a, LL b)",
			"{",
			"\ta = a % mod;",
			"\tb = b % mod;",
			"\treturn (((a * b) % mod) + mod) % mod;",
			"}",
			"",
			"LL mod_add(LL a, LL b)",
			"{",
			"\ta = a % mod;",
			"\tb = b % mod;",
			"\treturn (((a + b) % mod) + mod) % mod;",
			"}"
		]
	},
	"ncr": {
		"prefix": "ncr",
		"body": [
			"// Compute nCr % mod where mod is a large prime number",
			"// call prec_factorial in main once",
			"#define MAX_N_FACT (int)3e5 + 5",
			"vector<long long> factorial(MAX_N_FACT, 1), inverse_factorial(MAX_N_FACT, 1), inv(MAX_N_FACT, 1);",
			"void prec_factorials() {",
			"\tfor (int i = 2; i < MAX_N_FACT; i++) {",
			"\t\tfactorial[i] = factorial[i - 1] * i % mod;",
			"\t\tinv[i] = (mod - (mod / i) * inv[mod % i] % mod);",
			"\t\tinverse_factorial[i] = (inv[i] * inverse_factorial[i - 1]) % mod;",
			"\t}",
			"}",
			"long long ncr(int n, int k) {",
			"\treturn factorial[n] * inverse_factorial[k] % mod * inverse_factorial[n - k] % mod;",
			"}"
		],
		"description": "Calculate ncr%mod"
	},
	"linearDiophantine": {
		"prefix": "linearDiophantine",
		"body": [
			"// does not handle a=b=0 case",
			"int gcd(int a, int b, int& x, int& y) {",
			"\tif (b == 0) {",
			"\t\tx = 1;",
			"\t\ty = 0;",
			"\t\treturn a;",
			"\t}",
			"\tint x1, y1;",
			"\tint d = gcd(b, a % b, x1, y1);",
			"\tx = y1;",
			"\ty = x1 - y1 * (a / b);",
			"\treturn d;",
			"}",
			"",
			"bool find_any_solution(int a, int b, int c, int &x0, int &y0, int &g) {",
			"\tg = gcd(abs(a), abs(b), x0, y0);",
			"\tif (c % g) {",
			"\t\treturn false;",
			"\t}",
			"",
			"\tx0 *= c / g;",
			"\ty0 *= c / g;",
			"\tif (a < 0) x0 = -x0;",
			"\tif (b < 0) y0 = -y0;",
			"\treturn true;",
			"}",
			"",
			"void shift_solution(int & x, int & y, int a, int b, int cnt) {",
			"\tx += cnt * b;",
			"\ty -= cnt * a;",
			"}",
			"",
			"int find_all_solutions(int a, int b, int c, int minx, int maxx, int miny, int maxy) {",
			"\tint x, y, g;",
			"\tif (!find_any_solution(a, b, c, x, y, g))",
			"\t\treturn 0;",
			"\ta /= g;",
			"\tb /= g;",
			"",
			"\tint sign_a = a > 0 ? +1 : -1;",
			"\tint sign_b = b > 0 ? +1 : -1;",
			"",
			"\tshift_solution(x, y, a, b, (minx - x) / b);",
			"\tif (x < minx)",
			"\t\tshift_solution(x, y, a, b, sign_b);",
			"\tif (x > maxx)",
			"\t\treturn 0;",
			"\tint lx1 = x;",
			"",
			"\tshift_solution(x, y, a, b, (maxx - x) / b);",
			"\tif (x > maxx)",
			"\t\tshift_solution(x, y, a, b, -sign_b);",
			"\tint rx1 = x;",
			"",
			"\tshift_solution(x, y, a, b, -(miny - y) / a);",
			"\tif (y < miny)",
			"\t\tshift_solution(x, y, a, b, -sign_a);",
			"\tif (y > maxy)",
			"\t\treturn 0;",
			"\tint lx2 = x;",
			"",
			"\tshift_solution(x, y, a, b, -(maxy - y) / a);",
			"\tif (y > maxy)",
			"\t\tshift_solution(x, y, a, b, sign_a);",
			"\tint rx2 = x;",
			"",
			"\tif (lx2 > rx2)",
			"\t\tswap(lx2, rx2);",
			"\tint lx = max(lx1, lx2);",
			"\tint rx = min(rx1, rx2);",
			"",
			"\tif (lx > rx)",
			"\t\treturn 0;",
			"\t// if u want to enumerate through all solutions just iterate over x = lx + k*(b/g) for all k until x = rx",
			"\t// return mp(lx,rx);",
			"\treturn (rx - lx) / abs(b) + 1;",
			"}"
		],
		"description": "Finds solutions of a linear equation in a given range"
	},
	"Lowest Common Ancestor": {
		"prefix": "lca",
		"body": [
			"vvi graph, kanc;",
			"vi par, depth;",
			"",
			"void dfs(int root, int parent)",
			"{",
			"\tfor (auto x : graph[root])",
			"\t{",
			"\t\tif (x != parent)",
			"\t\t{",
			"\t\t\tpar[x] = root;",
			"\t\t\tdepth[x] = depth[root] + 1;",
			"\t\t\tdfs(x, root);",
			"\t\t}",
			"\t}",
			"}",
			"",
			"void prec(int n)",
			"{",
			"\tFOR(i, 1, n + 1)",
			"\t{",
			"\t\tkanc[i][0] = par[i];",
			"\t}",
			"\tFOR(j, 1, log2(n) + 2)",
			"\t{",
			"\t\tFOR(i, 1, n + 1)",
			"\t\t{",
			"\t\t\tkanc[i][j] = kanc[kanc[i][j - 1]][j - 1];",
			"\t\t}",
			"\t}",
			"}",
			"",
			"int lca(int a, int b)",
			"{",
			"\tif (depth[a] < depth[b])",
			"\t{",
			"\t\treturn lca(b, a);",
			"\t}",
			"\tint dist = depth[a] - depth[b];",
			"\tFOR(i, 0, sz(kanc[0]))",
			"\t{",
			"\t\tif ((1LL << i) & dist)",
			"\t\t{",
			"\t\t\ta = kanc[a][i];",
			"\t\t}",
			"\t}",
			"\tif (depth[a] != depth[b])",
			"\t{",
			"\t\tcout << \"WTF\" << endl;",
			"\t\treturn -1;",
			"\t}",
			"\tif (a == b)",
			"\t{",
			"\t\treturn a;",
			"\t}",
			"",
			"\tfrr(i, sz(kanc[0]) - 1, 0)",
			"\t{",
			"\t\tif (kanc[a][i] != kanc[b][i])",
			"\t\t{",
			"\t\t\ta = kanc[a][i];",
			"\t\t\tb = kanc[b][i];",
			"\t\t}",
			"\t}",
			"\treturn kanc[a][0];",
			"}"
		],
		"description": "Finds the lca in logn, first cal dfs, then prec and then lca"
	},
	"Lazy Segment Tree": {
		"prefix": "lazy segtree",
		"body": [
			"struct node {",
			"\tint sum, width;",
			"\tnode operator+(const node& n) {",
			"\t\treturn {sum + n.sum, width + n.width};",
			"\t}",
			"};",
			"struct update {",
			"\tbool type;  // 0 for add, 1 for reset",
			"\tint value;",
			"\tnode operator()(const node& n) {",
			"\t\tif (type)",
			"\t\t\treturn {n.width * value, n.width};",
			"\t\telse",
			"\t\t\treturn {n.sum + n.width * value, n.width};",
			"\t}",
			"\tupdate operator+(const update& u) {",
			"\t\tif (u.type) return u;",
			"\t\treturn {type, value + u.value};",
			"\t}",
			"};",
			"template <typename T, typename U>",
			"struct seg_tree_lazy {",
			"\tint S, H;",
			"\tT zero;",
			"\tvector<T> value;",
			"\tU noop;",
			"\tvector<bool> dirty;",
			"\tvector<U> prop;",
			"\tseg_tree_lazy(int _S, T _zero = T(), U _noop = U()) {",
			"\t\tzero = _zero, noop = _noop;",
			"\t\tfor (S = 1, H = 1; S < _S;) S *= 2, H++;",
			"\t\tvalue.resize(2 * S, zero), dirty.resize(2 * S, false);",
			"\t\tprop.resize(2 * S, noop);",
			"\t}",
			"\tvoid set_leaves(vector<T>& leaves) {",
			"\t\tcopy(leaves.begin(), leaves.end(), value.begin() + S);",
			"\t\tfor (int i = S - 1; i > 0; i--)",
			"\t\t\tvalue[i] = value[2 * i] + value[2 * i + 1];",
			"\t}",
			"\tvoid apply(int i, U& update) {",
			"\t\tvalue[i] = update(value[i]);",
			"\t\tif (i < S) {",
			"\t\t\tprop[i] = prop[i] + update;",
			"\t\t\tdirty[i] = true;",
			"\t\t}",
			"\t}",
			"\tvoid rebuild(int i) {",
			"\t\tfor (int l = i / 2; l; l /= 2) {",
			"\t\t\tT combined = value[2 * l] + value[2 * l + 1];",
			"\t\t\tvalue[l] = prop[l](combined);",
			"\t\t}",
			"\t}",
			"\tvoid propagate(int i) {",
			"\t\tfor (int h = H; h > 0; h--) {",
			"\t\t\tint l = i >> h;",
			"\t\t\tif (dirty[l]) {",
			"\t\t\t\tapply(2 * l, prop[l]);",
			"\t\t\t\tapply(2 * l + 1, prop[l]);",
			"\t\t\t\tprop[l] = noop;",
			"\t\t\t\tdirty[l] = false;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tvoid upd(int i, int j, U update) {",
			"\t\ti += S, j += S;",
			"\t\tpropagate(i), propagate(j);",
			"\t\tfor (int l = i, r = j; l <= r; l /= 2, r /= 2) {",
			"\t\t\tif ((l & 1) == 1) apply(l++, update);",
			"\t\t\tif ((r & 1) == 0) apply(r--, update);",
			"\t\t}",
			"\t\trebuild(i), rebuild(j);",
			"\t}",
			"\tT query(int i, int j) {",
			"\t\ti += S, j += S;",
			"\t\tpropagate(i), propagate(j);",
			"\t\tT res_left = zero, res_right = zero;",
			"\t\tfor (; i <= j; i /= 2, j /= 2) {",
			"\t\t\tif ((i & 1) == 1) res_left = res_left + value[i++];",
			"\t\t\tif ((j & 1) == 0) res_right = value[j--] + res_right;",
			"\t\t}",
			"\t\treturn res_left + res_right;",
			"\t}",
			"};"
		],
		"description": "lazy segtree O(4nlogn) ig"
	},
	"Mo's Algo": {
		"prefix": "mo's",
		"body": [
			"struct qu {",
			"\tint l, r, ind;",
			"};",
			"int B = 500;",
			"bool comp(qu a, qu b) {",
			"\tVI p1 = {a.l / B, a.r / B, a.ind};",
			"\tVI p2 = {b.l / B, b.r / B, b.ind};",
			"\tif (p1[0] < p2[0]) return true;",
			"\tif (p2[0] < p1[0]) return false;",
			"\tif (p1[1] < p2[1]) return true;",
			"\tif (p2[1] < p1[1]) return false;",
			"\tif (p1[2] < p2[2]) return true;",
			"\treturn false;",
			"}",
			"",
			"void mosAlgo() {",
			"\tvector<qu> qs(q);",
			"\tsort(qs.begin(), qs.end(), comp);",
			"\tint l = 0, r = -1;",
			"\tVI ans(q, -1);",
			"\tauto add = [&](int ind) {",
			"\t};",
			"\tauto remove = [&](int ind) {",
			"\t};",
			"\tfor (auto qq : qs) {",
			"\t\tint ql = qq.l;",
			"\t\tint qr = qq.r;",
			"\t\twhile (l > ql) add(--l);",
			"\t\twhile (r < qr) add(++r);",
			"\t\twhile (l < ql) remove(l++);",
			"\t\twhile (r > qr) remove(r--);",
			"\t\t// Get the current tans and update to ans vector",
			"\t\t// ans[qq.id] = tans;",
			"\t}",
			"}"
		],
		"description": "mo's without updates in n^1.5"
	},
	"MatrixExponentiation": {
		"prefix": "matrixexpo",
		"body": [
			"vvi mul(vvi a, vvi b)",
			"{",
			"\tint n = sz(a[0]);",
			"\tvvi res(n, vi(n, 0));",
			"\tfor (int i = 0; i < n; i++)",
			"\t{",
			"\t\tfor (int j = 0; j < n; j++)",
			"\t\t{",
			"\t\t\tfor (int k = 0; k < n; k++)",
			"\t\t\t{",
			"\t\t\t\tres[i][j] = mod_add(res[i][j], mod_mul(a[i][k], b[k][j]));",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn res;",
			"}",
			"// code to find (matrix)^k",
			"// matrix is n*n",
			"vvvi vals(32, vvi(n, vi(n, 0)));",
			"prec()",
			"{",
			"\tvals[0] = gmatrix; // initial matrix, might be I",
			"\tFOR(i, 1, 32)",
			"\t{",
			"\t\tvals[i] = mul(vals[i - 1], vals[i - 1]);",
			"\t}",
			"}",
			"// in solve",
			"vi bits;",
			"FOR(i, 0, 32) // change to 62 for long long",
			"{",
			"\tif ((1LL << i) & k)",
			"\t{",
			"\t\tbits.pb(i);",
			"\t}",
			"}",
			"vvi ans(n, vi(n, 0));",
			"FOR(i, 0, n)",
			"{",
			"\tans[i][i] = 1;",
			"}",
			"FOR(i, 0, sz(bits))",
			"{",
			"\tans = mul(ans, vals[bits[i]]);",
			"}"
		],
		"description": "find kth power of matrix in O(logk)"
	},
	"subtree_hashing": {
		"prefix": "tree_hash",
		"body": [
			"map<vector<int>, int> hasher;",
			"map<int, vi> rmap;",
			"",
			"vvi g;",
			"int hashify(vector<int> x)",
			"{",
			"\t// sort(all(x));",
			"\tif (!hasher[x])",
			"\t{",
			"\t\thasher[x] = hasher.size();",
			"\t}",
			"\treturn hasher[x];",
			"}",
			"",
			"int hashh(int v, int parent)",
			"{ // get a \"hash\" of v's subtree",
			"\tvector<int> children;",
			"\tfor (int u : g[v])",
			"\t{",
			"\t\tif (u != parent)",
			"\t\t{",
			"\t\t\tchildren.push_back(hashh(u, v));",
			"\t\t}",
			"\t}",
			"\tsort(all(children));",
			"\trmap[v] = children;",
			"\treturn hashify(children);",
			"}"
		],
		"description": "let's assign each rooted tree a unique number. Knowing the assigned number for a rooted tree is the same as knowing a multiset of assigned numbers of the subtrees of its root children. If we've already seen the multiset before, we extract its number from a map, otherwise, we assign it the first unassigned number. \r\nO(nlogn)"
	},
}
